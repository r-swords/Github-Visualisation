{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport useRect from './useRect'; //\n//\n// These are the keys used internally to look up and measure\n// different sides of a bounding box within another\n\nvar sideSchemas = {\n  left: {\n    side: 'left',\n    startKey: 'left',\n    lengthKey: 'width',\n    crossStartKey: 'top',\n    crossLengthKey: 'height',\n    fromEnd: false\n  },\n  right: {\n    side: 'right',\n    startKey: 'left',\n    lengthKey: 'width',\n    crossStartKey: 'top',\n    crossLengthKey: 'height',\n    fromEnd: true\n  },\n  top: {\n    side: 'top',\n    startKey: 'top',\n    lengthKey: 'height',\n    crossStartKey: 'left',\n    crossLengthKey: 'width',\n    fromEnd: false\n  },\n  bottom: {\n    side: 'bottom',\n    startKey: 'top',\n    lengthKey: 'height',\n    crossStartKey: 'left',\n    crossLengthKey: 'width',\n    fromEnd: true\n  }\n}; // This is the final Tootlip component. It's a render prop\n// that lets you attach handlers to elements, and render a tooltip\n// anchored to them in relation to the parent portal container (either the only\n// one defined or the one referenced by Id).\n\nexport function useAnchor(options) {\n  var portalDims = useRect(options.portalEl, options.show);\n  var anchorDims = useRect(options.anchorEl, options.show);\n  var tooltipDims = useRect(options.tooltipEl, options.show);\n  var sides = React.useMemo(function () {\n    var preSides = Array.isArray(options.side) ? options.side : [options.side];\n    return preSides.map(function (alignStr) {\n      var _ref = alignStr.split(' '),\n          side = _ref[0],\n          _ref$ = _ref[1],\n          align = _ref$ === void 0 ? 'center' : _ref$;\n\n      var incompatibleSide = !['top', 'right', 'bottom', 'left'].find(function (d) {\n        return side === d;\n      });\n\n      if (incompatibleSide) {\n        throw new Error(\"react-sticker: \\\"\" + side + \"\\\" is not a valid side! Must be one of ['top', 'right', 'bottom', 'left'].\");\n      }\n\n      var incompatibleAlign = !['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].find(function (d) {\n        return align === d;\n      });\n\n      if (incompatibleAlign) {\n        throw new Error(\"react-sticker: \\\"\" + align + \"\\\" is not a valid side-alignment! Must be one of ['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].\");\n      }\n\n      return [side, align];\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [JSON.stringify(options.side)]); // IF we have all of the dimensions needed to calculate\n  // fits, then calculate the fit\n\n  var ready = portalDims && tooltipDims && anchorDims;\n  var fit = React.useMemo(function () {\n    return ready && options.show ? fitOnBestSide({\n      portalDims: portalDims,\n      tooltipDims: tooltipDims,\n      anchorDims: anchorDims,\n      sides: sides,\n      useLargest: options.useLargest\n    }) : null;\n  }, [anchorDims, options.show, options.useLargest, portalDims, ready, sides, tooltipDims]);\n  return {\n    fit: fit,\n    style: _extends({\n      position: 'absolute',\n      visibility: ready ? 'visible' : 'hidden'\n    }, fit == null ? void 0 : fit.style)\n  };\n} // This function selects the best side for the tooltip by using\n// the ranked fits.\n\nfunction fitOnBestSide(_ref2) {\n  var portalDims = _ref2.portalDims,\n      tooltipDims = _ref2.tooltipDims,\n      anchorDims = _ref2.anchorDims,\n      sides = _ref2.sides,\n      useLargest = _ref2.useLargest;\n  var fits = sides.map(function (_ref3) {\n    var side = _ref3[0],\n        align = _ref3[1];\n    return measureFit(_extends({}, sideSchemas[side], {\n      align: align,\n      portalDims: portalDims,\n      tooltipDims: tooltipDims,\n      anchorDims: anchorDims\n    }));\n  });\n\n  if (useLargest) {\n    fits.sort(function (a, b) {\n      return b.fitRatio - a.fitRatio;\n    });\n    return fits[0];\n  }\n\n  return fits.find(function (fit) {\n    return fit.fitRatio >= 1;\n  }) || fits[0];\n} // This function takes a side and bunch of calculated dimensions from\n// the portal, tooltip and target. Then it returns\n// the percentage fit and the style to achieve this specific fit\n\n\nfunction measureFit(_ref4) {\n  var _style;\n\n  var side = _ref4.side,\n      align = _ref4.align,\n      startKey = _ref4.startKey,\n      lengthKey = _ref4.lengthKey,\n      crossStartKey = _ref4.crossStartKey,\n      crossLengthKey = _ref4.crossLengthKey,\n      fromEnd = _ref4.fromEnd,\n      portalDims = _ref4.portalDims,\n      tooltipDims = _ref4.tooltipDims,\n      anchorDims = _ref4.anchorDims;\n  var parentStart = portalDims[startKey];\n  var parentLength = portalDims[lengthKey];\n  var crossParentStart = portalDims[crossStartKey];\n  var crossParentLength = portalDims[crossLengthKey];\n  var anchorStart = anchorDims[startKey] - portalDims[startKey];\n  var anchorLength = anchorDims[lengthKey];\n  var crossAnchorStart = anchorDims[crossStartKey];\n  var crossAnchorLength = anchorDims[crossLengthKey];\n  var crossAnchorWidth = anchorDims[crossLengthKey];\n  var targetLength = tooltipDims[lengthKey];\n  var crossTargetLength = tooltipDims[crossLengthKey];\n  var targetStart;\n  var fitRatio;\n\n  if (!fromEnd) {\n    targetStart = anchorStart - targetLength;\n    fitRatio = Math.min(anchorStart / targetLength);\n  } else {\n    targetStart = anchorStart + anchorLength;\n    fitRatio = (parentLength - (anchorStart + anchorLength)) / targetLength;\n  }\n\n  targetStart = Math.max(parentStart, Math.min(targetStart, parentLength));\n  var crossTargetStart;\n\n  if (startKey === 'left') {\n    if (align === 'top') {\n      align = 'start';\n    } else if (align === 'bottom') {\n      align = 'end';\n    }\n  } else {\n    if (align === 'left') {\n      align = 'start';\n    } else if (align === 'right') {\n      align = 'end';\n    }\n  }\n\n  if (!['start', 'center', 'end'].includes(align)) {\n    align = 'center';\n  }\n\n  if (align === 'start') {\n    crossTargetStart = crossAnchorStart;\n  } else if (align === 'end') {\n    crossTargetStart = crossAnchorStart + crossAnchorWidth - crossTargetLength;\n  } else {\n    crossTargetStart = crossAnchorStart + crossAnchorLength / 2 - crossTargetLength / 2;\n  }\n\n  crossTargetStart = Math.max(crossParentStart, Math.min(crossTargetStart, crossParentLength - crossTargetLength));\n  return {\n    side: side,\n    align: align,\n    startKey: startKey,\n    lengthKey: lengthKey,\n    crossStartKey: crossStartKey,\n    crossLengthKey: crossLengthKey,\n    fromEnd: fromEnd,\n    portalDims: portalDims,\n    tooltipDims: tooltipDims,\n    anchorDims: anchorDims,\n    fitRatio: fitRatio,\n    style: (_style = {}, _style[startKey] = targetStart, _style[crossStartKey] = crossTargetStart, _style)\n  };\n}","map":{"version":3,"sources":["/home/ralph1/Documents/3rd_year/software_eng/react/github_visaulisation/node_modules/react-charts/es/hooks/useAnchor.js"],"names":["_extends","React","useRect","sideSchemas","left","side","startKey","lengthKey","crossStartKey","crossLengthKey","fromEnd","right","top","bottom","useAnchor","options","portalDims","portalEl","show","anchorDims","anchorEl","tooltipDims","tooltipEl","sides","useMemo","preSides","Array","isArray","map","alignStr","_ref","split","_ref$","align","incompatibleSide","find","d","Error","incompatibleAlign","JSON","stringify","ready","fit","fitOnBestSide","useLargest","style","position","visibility","_ref2","fits","_ref3","measureFit","sort","a","b","fitRatio","_ref4","_style","parentStart","parentLength","crossParentStart","crossParentLength","anchorStart","anchorLength","crossAnchorStart","crossAnchorLength","crossAnchorWidth","targetLength","crossTargetLength","targetStart","Math","min","max","crossTargetStart","includes"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport useRect from './useRect'; //\n//\n\n// These are the keys used internally to look up and measure\n// different sides of a bounding box within another\nvar sideSchemas = {\n  left: {\n    side: 'left',\n    startKey: 'left',\n    lengthKey: 'width',\n    crossStartKey: 'top',\n    crossLengthKey: 'height',\n    fromEnd: false\n  },\n  right: {\n    side: 'right',\n    startKey: 'left',\n    lengthKey: 'width',\n    crossStartKey: 'top',\n    crossLengthKey: 'height',\n    fromEnd: true\n  },\n  top: {\n    side: 'top',\n    startKey: 'top',\n    lengthKey: 'height',\n    crossStartKey: 'left',\n    crossLengthKey: 'width',\n    fromEnd: false\n  },\n  bottom: {\n    side: 'bottom',\n    startKey: 'top',\n    lengthKey: 'height',\n    crossStartKey: 'left',\n    crossLengthKey: 'width',\n    fromEnd: true\n  }\n}; // This is the final Tootlip component. It's a render prop\n// that lets you attach handlers to elements, and render a tooltip\n// anchored to them in relation to the parent portal container (either the only\n// one defined or the one referenced by Id).\n\nexport function useAnchor(options) {\n  var portalDims = useRect(options.portalEl, options.show);\n  var anchorDims = useRect(options.anchorEl, options.show);\n  var tooltipDims = useRect(options.tooltipEl, options.show);\n  var sides = React.useMemo(function () {\n    var preSides = Array.isArray(options.side) ? options.side : [options.side];\n    return preSides.map(function (alignStr) {\n      var _ref = alignStr.split(' '),\n          side = _ref[0],\n          _ref$ = _ref[1],\n          align = _ref$ === void 0 ? 'center' : _ref$;\n\n      var incompatibleSide = !['top', 'right', 'bottom', 'left'].find(function (d) {\n        return side === d;\n      });\n\n      if (incompatibleSide) {\n        throw new Error(\"react-sticker: \\\"\" + side + \"\\\" is not a valid side! Must be one of ['top', 'right', 'bottom', 'left'].\");\n      }\n\n      var incompatibleAlign = !['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].find(function (d) {\n        return align === d;\n      });\n\n      if (incompatibleAlign) {\n        throw new Error(\"react-sticker: \\\"\" + align + \"\\\" is not a valid side-alignment! Must be one of ['center', 'start', 'end', 'top', 'right', 'bottom', 'left'].\");\n      }\n\n      return [side, align];\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [JSON.stringify(options.side)]); // IF we have all of the dimensions needed to calculate\n  // fits, then calculate the fit\n\n  var ready = portalDims && tooltipDims && anchorDims;\n  var fit = React.useMemo(function () {\n    return ready && options.show ? fitOnBestSide({\n      portalDims: portalDims,\n      tooltipDims: tooltipDims,\n      anchorDims: anchorDims,\n      sides: sides,\n      useLargest: options.useLargest\n    }) : null;\n  }, [anchorDims, options.show, options.useLargest, portalDims, ready, sides, tooltipDims]);\n  return {\n    fit: fit,\n    style: _extends({\n      position: 'absolute',\n      visibility: ready ? 'visible' : 'hidden'\n    }, fit == null ? void 0 : fit.style)\n  };\n} // This function selects the best side for the tooltip by using\n// the ranked fits.\n\nfunction fitOnBestSide(_ref2) {\n  var portalDims = _ref2.portalDims,\n      tooltipDims = _ref2.tooltipDims,\n      anchorDims = _ref2.anchorDims,\n      sides = _ref2.sides,\n      useLargest = _ref2.useLargest;\n  var fits = sides.map(function (_ref3) {\n    var side = _ref3[0],\n        align = _ref3[1];\n    return measureFit(_extends({}, sideSchemas[side], {\n      align: align,\n      portalDims: portalDims,\n      tooltipDims: tooltipDims,\n      anchorDims: anchorDims\n    }));\n  });\n\n  if (useLargest) {\n    fits.sort(function (a, b) {\n      return b.fitRatio - a.fitRatio;\n    });\n    return fits[0];\n  }\n\n  return fits.find(function (fit) {\n    return fit.fitRatio >= 1;\n  }) || fits[0];\n} // This function takes a side and bunch of calculated dimensions from\n// the portal, tooltip and target. Then it returns\n// the percentage fit and the style to achieve this specific fit\n\n\nfunction measureFit(_ref4) {\n  var _style;\n\n  var side = _ref4.side,\n      align = _ref4.align,\n      startKey = _ref4.startKey,\n      lengthKey = _ref4.lengthKey,\n      crossStartKey = _ref4.crossStartKey,\n      crossLengthKey = _ref4.crossLengthKey,\n      fromEnd = _ref4.fromEnd,\n      portalDims = _ref4.portalDims,\n      tooltipDims = _ref4.tooltipDims,\n      anchorDims = _ref4.anchorDims;\n  var parentStart = portalDims[startKey];\n  var parentLength = portalDims[lengthKey];\n  var crossParentStart = portalDims[crossStartKey];\n  var crossParentLength = portalDims[crossLengthKey];\n  var anchorStart = anchorDims[startKey] - portalDims[startKey];\n  var anchorLength = anchorDims[lengthKey];\n  var crossAnchorStart = anchorDims[crossStartKey];\n  var crossAnchorLength = anchorDims[crossLengthKey];\n  var crossAnchorWidth = anchorDims[crossLengthKey];\n  var targetLength = tooltipDims[lengthKey];\n  var crossTargetLength = tooltipDims[crossLengthKey];\n  var targetStart;\n  var fitRatio;\n\n  if (!fromEnd) {\n    targetStart = anchorStart - targetLength;\n    fitRatio = Math.min(anchorStart / targetLength);\n  } else {\n    targetStart = anchorStart + anchorLength;\n    fitRatio = (parentLength - (anchorStart + anchorLength)) / targetLength;\n  }\n\n  targetStart = Math.max(parentStart, Math.min(targetStart, parentLength));\n  var crossTargetStart;\n\n  if (startKey === 'left') {\n    if (align === 'top') {\n      align = 'start';\n    } else if (align === 'bottom') {\n      align = 'end';\n    }\n  } else {\n    if (align === 'left') {\n      align = 'start';\n    } else if (align === 'right') {\n      align = 'end';\n    }\n  }\n\n  if (!['start', 'center', 'end'].includes(align)) {\n    align = 'center';\n  }\n\n  if (align === 'start') {\n    crossTargetStart = crossAnchorStart;\n  } else if (align === 'end') {\n    crossTargetStart = crossAnchorStart + crossAnchorWidth - crossTargetLength;\n  } else {\n    crossTargetStart = crossAnchorStart + crossAnchorLength / 2 - crossTargetLength / 2;\n  }\n\n  crossTargetStart = Math.max(crossParentStart, Math.min(crossTargetStart, crossParentLength - crossTargetLength));\n  return {\n    side: side,\n    align: align,\n    startKey: startKey,\n    lengthKey: lengthKey,\n    crossStartKey: crossStartKey,\n    crossLengthKey: crossLengthKey,\n    fromEnd: fromEnd,\n    portalDims: portalDims,\n    tooltipDims: tooltipDims,\n    anchorDims: anchorDims,\n    fitRatio: fitRatio,\n    style: (_style = {}, _style[startKey] = targetStart, _style[crossStartKey] = crossTargetStart, _style)\n  };\n}"]},"metadata":{},"sourceType":"module"}