{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport useIsomorphicLayoutEffect from '../hooks/useIsomorphicLayoutEffect';\nimport useChartContext from '../utils/chartContext';\n\nvar getElBox = function getElBox(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    top: Math.round(rect.top),\n    right: Math.round(rect.right),\n    bottom: Math.round(rect.bottom),\n    left: Math.round(rect.left),\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    x: Math.round(rect.x),\n    y: Math.round(rect.y)\n  };\n};\n\nexport default function useMeasure(_ref) {\n  var axis = _ref.axis,\n      elRef = _ref.elRef,\n      gridDimensions = _ref.gridDimensions,\n      setShowRotated = _ref.setShowRotated;\n\n  var _useChartContext = useChartContext(),\n      axisDimensionsState = _useChartContext.axisDimensionsState;\n\n  var axisDimensions = axisDimensionsState[0],\n      setAxisDimensions = axisDimensionsState[1];\n  var axisDimension = React.useMemo(function () {\n    var _axisDimensions;\n\n    return (_axisDimensions = axisDimensions[axis.position]) == null ? void 0 : _axisDimensions[axis.id];\n  }, [axisDimensions, axis.position, axis.id]); // const isLooping = useIsLooping()\n\n  var measureRotation = React.useCallback(function () {\n    var _widestLabel2;\n\n    if (!elRef.current) {\n      return;\n    }\n\n    var gridSize = !axis.isVertical ? gridDimensions.width : gridDimensions.height;\n    var staticLabelDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.outer .tickLabel')).map(function (el) {\n      return getElBox(el);\n    }); // Determine the largest labels on the axis\n\n    var widestLabel;\n    staticLabelDims.forEach(function (label) {\n      var _widestLabel;\n\n      var resolvedLabel = (_widestLabel = widestLabel) != null ? _widestLabel : {\n        width: 0\n      };\n\n      if (label.width > 0 && label.width > resolvedLabel.width) {\n        widestLabel = label;\n      }\n    });\n    var smallestTickGap = gridSize;\n\n    if (staticLabelDims.length > 1) {\n      staticLabelDims.forEach(function (current, i) {\n        var prev = staticLabelDims[i - 1];\n\n        if (prev) {\n          smallestTickGap = Math.min(smallestTickGap, axis.isVertical ? current.top - prev.top : current.left - prev.left);\n        }\n      });\n    }\n\n    var shouldRotate = (((_widestLabel2 = widestLabel) == null ? void 0 : _widestLabel2.width) || 0) + axis.minTickPaddingForRotation > smallestTickGap; // if (!isLooping) {\n    // Rotate ticks for non-time horizontal axes\n\n    if (!axis.isVertical) {\n      setShowRotated(shouldRotate);\n    } // }\n\n  }, [elRef, axis.isVertical, axis.minTickPaddingForRotation, gridDimensions.width, gridDimensions.height, setShowRotated]);\n  var measureDimensions = React.useCallback(function () {\n    if (!elRef.current) {\n      if (axisDimension) {\n        // If the entire axis is hidden, then we need to remove the axis dimensions\n        setAxisDimensions(function (old) {\n          var _old$axis$position, _extends2;\n\n          var newAxes = _extends({}, (_old$axis$position = old[axis.position]) != null ? _old$axis$position : {});\n\n          delete newAxes[axis.id];\n          return _extends({}, old, (_extends2 = {}, _extends2[axis.position] = newAxes, _extends2));\n        });\n      }\n\n      return;\n    }\n\n    var newDimensions = {\n      width: 0,\n      height: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingRight: 0\n    };\n    var currentEl = elRef.current;\n    var axisEl = currentEl.querySelector(\".Axis-Group.inner .domainAndTicks\");\n    var domainEl = currentEl.querySelector(\".Axis-Group.inner .domain\");\n\n    if (!axisEl || !domainEl) {\n      return;\n    }\n\n    var axisDims = getElBox(axisEl);\n    var domainDims = getElBox(domainEl);\n\n    if (!axisDims || !domainDims) {\n      return;\n    } // Axis overflow measurements\n\n\n    if (!axis.isVertical) {\n      newDimensions.paddingLeft = Math.round(Math.max(0, domainDims.left - (axisDims == null ? void 0 : axisDims.left)));\n      newDimensions.paddingRight = Math.round(Math.max(0, (axisDims == null ? void 0 : axisDims.right) - domainDims.right));\n      newDimensions.height = axisDims == null ? void 0 : axisDims.height;\n    } else {\n      newDimensions.paddingTop = Math.round(Math.max(0, domainDims.top - (axisDims == null ? void 0 : axisDims.top)));\n      newDimensions.paddingBottom = Math.round(Math.max(0, (axisDims == null ? void 0 : axisDims.bottom) - domainDims.bottom));\n      newDimensions.width = axisDims == null ? void 0 : axisDims.width;\n    } // Only update the axisDimensions if something has changed\n\n\n    if ( // !isLooping &&\n    !axisDimensions || !axisDimension || Object.keys(newDimensions).some(function (key) {\n      // @ts-ignore\n      return newDimensions[key] !== axisDimension[key];\n    })) {\n      setAxisDimensions(function (old) {\n        var _old$axis$position2, _extends3, _extends4;\n\n        return _extends({}, old, (_extends4 = {}, _extends4[axis.position] = _extends({}, (_old$axis$position2 = old[axis.position]) != null ? _old$axis$position2 : {}, (_extends3 = {}, _extends3[axis.id] = newDimensions, _extends3)), _extends4));\n      });\n    }\n  }, [axis.id, axis.isVertical, axis.position, axisDimension, axisDimensions, elRef, setAxisDimensions]); // Measure after if needed\n\n  useIsomorphicLayoutEffect(function () {\n    // setTimeout(() => {\n    window.requestAnimationFrame(function () {\n      measureRotation();\n      measureDimensions();\n    });\n  }, [measureRotation]); // useIsomorphicLayoutEffect(() => {\n  //   // setTimeout(() => {\n  //   window.requestAnimationFrame(() => {\n  //   })\n  // }, [measureRotation])\n}","map":{"version":3,"sources":["/home/ralph1/Documents/3rd_year/software_eng/react/github_visaulisation/node_modules/react-charts/es/components/AxisLinear.useMeasure.js"],"names":["_extends","React","useIsomorphicLayoutEffect","useChartContext","getElBox","el","rect","getBoundingClientRect","top","Math","round","right","bottom","left","width","height","x","y","useMeasure","_ref","axis","elRef","gridDimensions","setShowRotated","_useChartContext","axisDimensionsState","axisDimensions","setAxisDimensions","axisDimension","useMemo","_axisDimensions","position","id","measureRotation","useCallback","_widestLabel2","current","gridSize","isVertical","staticLabelDims","Array","from","querySelectorAll","map","widestLabel","forEach","label","_widestLabel","resolvedLabel","smallestTickGap","length","i","prev","min","shouldRotate","minTickPaddingForRotation","measureDimensions","old","_old$axis$position","_extends2","newAxes","newDimensions","paddingTop","paddingBottom","paddingLeft","paddingRight","currentEl","axisEl","querySelector","domainEl","axisDims","domainDims","max","Object","keys","some","key","_old$axis$position2","_extends3","_extends4","window","requestAnimationFrame"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport useIsomorphicLayoutEffect from '../hooks/useIsomorphicLayoutEffect';\nimport useChartContext from '../utils/chartContext';\n\nvar getElBox = function getElBox(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    top: Math.round(rect.top),\n    right: Math.round(rect.right),\n    bottom: Math.round(rect.bottom),\n    left: Math.round(rect.left),\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    x: Math.round(rect.x),\n    y: Math.round(rect.y)\n  };\n};\n\nexport default function useMeasure(_ref) {\n  var axis = _ref.axis,\n      elRef = _ref.elRef,\n      gridDimensions = _ref.gridDimensions,\n      setShowRotated = _ref.setShowRotated;\n\n  var _useChartContext = useChartContext(),\n      axisDimensionsState = _useChartContext.axisDimensionsState;\n\n  var axisDimensions = axisDimensionsState[0],\n      setAxisDimensions = axisDimensionsState[1];\n  var axisDimension = React.useMemo(function () {\n    var _axisDimensions;\n\n    return (_axisDimensions = axisDimensions[axis.position]) == null ? void 0 : _axisDimensions[axis.id];\n  }, [axisDimensions, axis.position, axis.id]); // const isLooping = useIsLooping()\n\n  var measureRotation = React.useCallback(function () {\n    var _widestLabel2;\n\n    if (!elRef.current) {\n      return;\n    }\n\n    var gridSize = !axis.isVertical ? gridDimensions.width : gridDimensions.height;\n    var staticLabelDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.outer .tickLabel')).map(function (el) {\n      return getElBox(el);\n    }); // Determine the largest labels on the axis\n\n    var widestLabel;\n    staticLabelDims.forEach(function (label) {\n      var _widestLabel;\n\n      var resolvedLabel = (_widestLabel = widestLabel) != null ? _widestLabel : {\n        width: 0\n      };\n\n      if (label.width > 0 && label.width > resolvedLabel.width) {\n        widestLabel = label;\n      }\n    });\n    var smallestTickGap = gridSize;\n\n    if (staticLabelDims.length > 1) {\n      staticLabelDims.forEach(function (current, i) {\n        var prev = staticLabelDims[i - 1];\n\n        if (prev) {\n          smallestTickGap = Math.min(smallestTickGap, axis.isVertical ? current.top - prev.top : current.left - prev.left);\n        }\n      });\n    }\n\n    var shouldRotate = (((_widestLabel2 = widestLabel) == null ? void 0 : _widestLabel2.width) || 0) + axis.minTickPaddingForRotation > smallestTickGap; // if (!isLooping) {\n    // Rotate ticks for non-time horizontal axes\n\n    if (!axis.isVertical) {\n      setShowRotated(shouldRotate);\n    } // }\n\n  }, [elRef, axis.isVertical, axis.minTickPaddingForRotation, gridDimensions.width, gridDimensions.height, setShowRotated]);\n  var measureDimensions = React.useCallback(function () {\n    if (!elRef.current) {\n      if (axisDimension) {\n        // If the entire axis is hidden, then we need to remove the axis dimensions\n        setAxisDimensions(function (old) {\n          var _old$axis$position, _extends2;\n\n          var newAxes = _extends({}, (_old$axis$position = old[axis.position]) != null ? _old$axis$position : {});\n\n          delete newAxes[axis.id];\n          return _extends({}, old, (_extends2 = {}, _extends2[axis.position] = newAxes, _extends2));\n        });\n      }\n\n      return;\n    }\n\n    var newDimensions = {\n      width: 0,\n      height: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingRight: 0\n    };\n    var currentEl = elRef.current;\n    var axisEl = currentEl.querySelector(\".Axis-Group.inner .domainAndTicks\");\n    var domainEl = currentEl.querySelector(\".Axis-Group.inner .domain\");\n\n    if (!axisEl || !domainEl) {\n      return;\n    }\n\n    var axisDims = getElBox(axisEl);\n    var domainDims = getElBox(domainEl);\n\n    if (!axisDims || !domainDims) {\n      return;\n    } // Axis overflow measurements\n\n\n    if (!axis.isVertical) {\n      newDimensions.paddingLeft = Math.round(Math.max(0, domainDims.left - (axisDims == null ? void 0 : axisDims.left)));\n      newDimensions.paddingRight = Math.round(Math.max(0, (axisDims == null ? void 0 : axisDims.right) - domainDims.right));\n      newDimensions.height = axisDims == null ? void 0 : axisDims.height;\n    } else {\n      newDimensions.paddingTop = Math.round(Math.max(0, domainDims.top - (axisDims == null ? void 0 : axisDims.top)));\n      newDimensions.paddingBottom = Math.round(Math.max(0, (axisDims == null ? void 0 : axisDims.bottom) - domainDims.bottom));\n      newDimensions.width = axisDims == null ? void 0 : axisDims.width;\n    } // Only update the axisDimensions if something has changed\n\n\n    if ( // !isLooping &&\n    !axisDimensions || !axisDimension || Object.keys(newDimensions).some(function (key) {\n      // @ts-ignore\n      return newDimensions[key] !== axisDimension[key];\n    })) {\n      setAxisDimensions(function (old) {\n        var _old$axis$position2, _extends3, _extends4;\n\n        return _extends({}, old, (_extends4 = {}, _extends4[axis.position] = _extends({}, (_old$axis$position2 = old[axis.position]) != null ? _old$axis$position2 : {}, (_extends3 = {}, _extends3[axis.id] = newDimensions, _extends3)), _extends4));\n      });\n    }\n  }, [axis.id, axis.isVertical, axis.position, axisDimension, axisDimensions, elRef, setAxisDimensions]); // Measure after if needed\n\n  useIsomorphicLayoutEffect(function () {\n    // setTimeout(() => {\n    window.requestAnimationFrame(function () {\n      measureRotation();\n      measureDimensions();\n    });\n  }, [measureRotation]); // useIsomorphicLayoutEffect(() => {\n  //   // setTimeout(() => {\n  //   window.requestAnimationFrame(() => {\n  //   })\n  // }, [measureRotation])\n}"]},"metadata":{},"sourceType":"module"}